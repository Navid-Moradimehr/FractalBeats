<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cosmic Neon Mandelbulb Visualizer</title>
  <style>
    html,body {margin:0; height:100%; background:black; overflow:hidden;}
    #ui {position:absolute; top:10px; right:10px; z-index:10;}
    input[type="file"]{color:white;}
  </style>
</head>
<body>
  <input id="audioFile" type="file" accept="audio/*"/>
  <div id="ui"></div>
  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
    import { GUI } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/libs/lil-gui.module.min.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({canvas});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    const scene = new THREE.Scene();
    const camera = new THREE.Camera();

    const uniforms = {
      u_time: {value:0},
      u_resolution:{value:new THREE.Vector2(innerWidth, innerHeight)},
      u_audioLow:{value:0},
      u_audioMid:{value:0},
      u_audioHigh:{value:0},
      u_intensity:{value:1.0},
      u_power:{value:8.0},
      u_hueShift:{value:0.0},
      u_shapeMod:{value:0.5},
      u_distortion:{value:0.3},
      u_rotationSpeed:{value:0.5},
      u_chaos:{value:0.4},
      u_morphing:{value:0.6},
      u_frequencyResponse:{value:0.8},
      u_shapeRegen:{value:0.6},
      u_beatSync:{value:0.8},
      u_structureChange:{value:0.5},
      u_breathing:{value:0.3},
      u_pulse:{value:0.4},
      u_beatIntensity:{value:0.0},
      u_energy:{value:0.0}
    };

    let material, mesh;
    async function initShader(){
      const frag = await fetch('shader.glsl').then(r=>r.text());
      material = new THREE.ShaderMaterial({
        uniforms,
        fragmentShader: frag,
        vertexShader:`void main(){gl_Position=vec4(position,1.0);}`
      });
      mesh = new THREE.Mesh(new THREE.PlaneGeometry(2,2), material);
      scene.add(mesh);
    }

    await initShader();

    const gui = new GUI({container:document.getElementById('ui')});
    gui.add(uniforms.u_intensity,'value',0.2,3.0,0.01).name('Intensity');
    gui.add(uniforms.u_power,'value',2.0,12.0,0.1).name('Power');
    gui.add(uniforms.u_hueShift,'value',0.0,6.283,0.01).name('HueShift');
    gui.add(uniforms.u_shapeMod,'value',0.0,2.0,0.01).name('Shape Mod');
    gui.add(uniforms.u_distortion,'value',0.0,1.0,0.01).name('Distortion');
    gui.add(uniforms.u_rotationSpeed,'value',0.0,2.0,0.01).name('Rot Speed');
    gui.add(uniforms.u_chaos,'value',0.0,1.5,0.01).name('Chaos');
    gui.add(uniforms.u_morphing,'value',0.0,1.5,0.01).name('Morphing');
    gui.add(uniforms.u_frequencyResponse,'value',0.0,2.0,0.01).name('Freq Response');
    gui.add(uniforms.u_shapeRegen,'value',0.0,1.5,0.01).name('Shape Regen');
    gui.add(uniforms.u_beatSync,'value',0.0,2.0,0.01).name('Beat Sync');
    gui.add(uniforms.u_structureChange,'value',0.0,1.5,0.01).name('Structure');
    gui.add(uniforms.u_breathing,'value',0.0,1.0,0.01).name('Breathing');
    gui.add(uniforms.u_pulse,'value',0.0,1.0,0.01).name('Pulse');

    // Enhanced Audio setup with beat detection
    const fileInput = document.getElementById('audioFile');
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048; // Increased for better frequency resolution
    const data = new Uint8Array(analyser.frequencyBinCount);
    const prevData = new Uint8Array(analyser.frequencyBinCount);
    let srcNode=null;
    
    // Beat detection variables
    let lastBeatTime = 0;
    let beatThreshold = 0.3;
    let energyHistory = [];
    const historyLength = 20;

    fileInput.onchange = e=>{
      if(srcNode) srcNode.disconnect();
      const file = e.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = ev=>{
        audioCtx.decodeAudioData(ev.target.result, buf=>{
          const bufferSource = audioCtx.createBufferSource();
          bufferSource.buffer = buf;
          bufferSource.connect(analyser);
          analyser.connect(audioCtx.destination);
          bufferSource.start();
          srcNode=bufferSource;
        });
      };
      reader.readAsArrayBuffer(file);
    };

    function updateAudio(){
      // Store previous frame data for beat detection
      prevData.set(data);
      analyser.getByteFrequencyData(data);
      
      let bass=0, mid=0, high=0;
      const l=data.length;
      for(let i=0;i<l;i++){
        const v=data[i]/255;
        if(i<l/3) bass+=v;
        else if(i<2*l/3) mid+=v;
        else high+=v;
      }
      bass/=l/3; mid/=l/3; high/=l/3;
      
      // Calculate total energy for beat detection
      const totalEnergy = (bass + mid + high) / 3;
      energyHistory.push(totalEnergy);
      if(energyHistory.length > historyLength) energyHistory.shift();
      
      // Beat detection using spectral flux
      let spectralFlux = 0;
      for(let i=0; i<l; i++){
        const diff = (data[i]/255) - (prevData[i]/255);
        if(diff > 0) spectralFlux += diff;
      }
      spectralFlux /= l;
      
      // Calculate average energy for threshold
      const avgEnergy = energyHistory.reduce((a,b) => a+b, 0) / energyHistory.length;
      const beatThreshold = avgEnergy * 1.3; // Dynamic threshold
      
      // Detect beat
      let beatDetected = false;
      if(spectralFlux > beatThreshold && (Date.now() - lastBeatTime) > 200){
        beatDetected = true;
        lastBeatTime = Date.now();
      }
      
      // Attack/Release envelopes for more natural response
      const attackRate = 0.15; // Fast attack
      const releaseRate = 0.03; // Slow release
      
      // Apply different smoothing for attack vs release
      const bassDiff = bass - uniforms.u_audioLow.value;
      const midDiff = mid - uniforms.u_audioMid.value;
      const highDiff = high - uniforms.u_audioHigh.value;
      
      const bassRate = bassDiff > 0 ? attackRate : releaseRate;
      const midRate = midDiff > 0 ? attackRate : releaseRate;
      const highRate = highDiff > 0 ? attackRate : releaseRate;
      
      uniforms.u_audioLow.value += bassDiff * bassRate;
      uniforms.u_audioMid.value += midDiff * midRate;
      uniforms.u_audioHigh.value += highDiff * highRate;
      
      // Update new uniforms
      uniforms.u_beatIntensity.value = beatDetected ? 1.0 : Math.max(0, uniforms.u_beatIntensity.value - 0.1);
      uniforms.u_energy.value = totalEnergy;
    }

    function resize(){
      renderer.setSize(innerWidth, innerHeight);
      uniforms.u_resolution.value.set(innerWidth, innerHeight);
    }
    addEventListener('resize',resize);

    let clock=new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      uniforms.u_time.value = clock.getElapsedTime();
      updateAudio();
      renderer.render(scene,camera);
    }
    animate();
  </script>
</body>
</html>
